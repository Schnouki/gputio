#!/usr/bin/env python2
# -*- mode: python -*-
#
# Copyright (c) 2010, Thomas Jost <schnouki@schnouki.net>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import ConfigParser
import gettext
import locale
import os
import os.path
import sys
import threading
import time
import traceback

import putio
import pycurl

import pygtk
pygtk.require('2.0')
import gio
import glib
import gobject
import gtk

# Mapping between Put.io file type and Gtk icon names.
TYPE_TO_ICON = {
    "folder":     "folder",
    "file":       "unknown",
    "autio":      "sound",
    "movie":      "video-x-generic",
    "image":      "image",
    "compressed": "package",
    "pdf":        "document",
    "ms_doc":     "document",
    "text":       "txt",
    "swf":        "shellscript",
    }

class GPutIO(object):
    def __init__(self, username, password, apikey, apisecret):
        # Main window
        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_title("GPutio")
        self.win.set_default_size(640, 480)
        self.win.connect("destroy", self.destroy)
        vpaned = gtk.VPaned()
        self.win.add(vpaned)

        # Frames, alignments, and horizontal boxes
        frm_files = gtk.Frame(_("<b>Your files</b>"))
        frm_files.get_label_widget().set_use_markup(True)
        align_files = gtk.Alignment(.5, .5, 1., 1.)
        align_files.set_padding(2, 0, 12, 0)
        frm_files.add(align_files)
        vpaned.pack1(frm_files, resize=True)
        hbox_files = gtk.HBox()
        align_files.add(hbox_files)

        frm_dl = gtk.Frame(_("<b>Download queue</b>"))
        frm_dl.get_label_widget().set_use_markup(True)
        align_dl = gtk.Alignment(.5, .5, 1., 1.)
        align_dl.set_padding(2, 0, 12, 0)
        frm_dl.add(align_dl)
        vpaned.pack2(frm_dl, resize=False)
        hbox_dl = gtk.HBox()
        align_dl.add(hbox_dl)

        # Data stores
        # - TreeStore for the files tree: name, size, icon, ID, URL, full path
        self.tree = gtk.TreeStore(str, int, gtk.gdk.Pixbuf, int, str, str)
        # - ListStore for the downloads: name, URL, total size, downloaded size, current speed
        self.list = gtk.ListStore(str, str, int, int, float)

        # Frames and scrolled windows for TreeViews
        ff = gtk.Frame()
        hbox_files.pack_start(ff)
        swf = gtk.ScrolledWindow()
        swf.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        ff.add(swf)

        fd = gtk.Frame()
        hbox_dl.pack_start(fd)
        swd = gtk.ScrolledWindow()
        swd.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        fd.add(swd)

        # Toolbars
        tb_files = gtk.Toolbar()
        tb_files.set_orientation(gtk.ORIENTATION_VERTICAL)
        tb_files.set_style(gtk.TOOLBAR_ICONS)
        hbox_files.pack_start(tb_files, expand=False)

        tb_dl = gtk.Toolbar()
        tb_dl.set_orientation(gtk.ORIENTATION_VERTICAL)
        tb_dl.set_style(gtk.TOOLBAR_ICONS)
        hbox_dl.pack_start(tb_dl, expand=False)

        # Toolbar buttons
        tb_files.insert_stock(gtk.STOCK_REFRESH, _("Refresh files list"), None, self.refresh, None, -1)
        tb_files.append_space()
        tb_files.insert_stock(gtk.STOCK_SAVE, _("Download the selection"), None, self.download, None, -1)
        tb_files.insert_stock(gtk.STOCK_DELETE, _("Remove the selection"), None, self.remove, None, -1)

        tb_dl.insert_stock(gtk.STOCK_CANCEL, _("Cancel current download"), None, None, None, -1)
        tb_dl.insert_stock(gtk.STOCK_DELETE, _("Remove the selection from the download queue"), None, None, None, -1)

        # TreeView for the files tree
        self.tvf = gtk.TreeView(self.tree)
        swf.add(self.tvf)
        self.tvf.set_enable_tree_lines(True)
        self.tvf.set_search_column(0)
        self.tvf.set_rules_hint(True)
        self.tvf.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

        # TreeView for the downloads list
        self.tvd = gtk.TreeView(self.list)
        swd.add(self.tvd)
        self.tvd.set_search_column(0)
        self.tvd.set_rules_hint(True)

        # Cell renderers
        cell_txt = gtk.CellRendererText()
        cell_txt_right = gtk.CellRendererText()
        cell_txt_right.set_property("xalign", 1.0)
        cell_pb = gtk.CellRendererPixbuf()
        cell_prog = gtk.CellRendererProgress()

        # Add columns
        tvc = gtk.TreeViewColumn(_("Name"))
        tvc.pack_start(cell_pb, expand=False)
        tvc.pack_start(cell_txt)
        tvc.add_attribute(cell_txt, "text", 0)
        tvc.add_attribute(cell_pb, "pixbuf", 2)
        tvc.set_expand(True)
        tvc.set_sort_column_id(0)
        self.tvf.append_column(tvc)

        tvc = gtk.TreeViewColumn(_("Size"), cell_txt_right)
        tvc.set_cell_data_func(cell_txt_right, self._render_size)
        tvc.set_sort_column_id(1)
        self.tvf.append_column(tvc)

        tvc = gtk.TreeViewColumn(_("File name"), cell_txt, text=0)
        tvc.set_sort_column_id(0)
        tvc.set_expand(True)
        tvc.set_resizable(True)
        self.tvd.append_column(tvc)

        tvc = gtk.TreeViewColumn(_("Progress"), cell_prog)
        tvc.set_cell_data_func(cell_prog, self._render_progress)
        tvc.set_sort_column_id(3)
        tvc.set_min_width(150)
        tvc.set_resizable(True)
        self.tvd.append_column(tvc)

        tvc = gtk.TreeViewColumn(_("Speed"), cell_txt_right)
        tvc.set_cell_data_func(cell_txt_right, self._render_speed)
        tvc.set_sort_column_id(4)
        tvc.set_min_width(100)
        tvc.set_resizable(True)
        self.tvd.append_column(tvc)

        tvc = gtk.TreeViewColumn(_("ETA"), cell_txt_right)
        tvc.set_cell_data_func(cell_txt_right, self._render_eta)
        tvc.set_min_width(100)
        tvc.set_resizable(True)
        self.tvd.append_column(tvc)

        self.tvd.set_tooltip_column(1)

        # Default sorting order
        self.tree.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.list.set_sort_column_id(0, gtk.SORT_ASCENDING)

        # API init
        self.api = putio.Api(apikey, apisecret)
        self.username = username
        self.password = password

        # Icons
        self.theme = gtk.icon_theme_get_default()
        self.icons = {}

        # Download manager
        self.dl_event = threading.Event()
        self.dl_quit = False
        self.dl_thr = threading.Thread(target=self._download_thread)
        self.dl_thr.daemon = True
        self.dl_thr.start()

        self.win.show_all()

        self.refresh()

    # Render a file size in a CellRenderer
    def _render_size(self, col, cell, model, iter, data=None):
        size = model.get_value(iter, 1)
        if size <= 0:
            size = ""
        elif size < 1024:
            size = locale.format_string(_("%d B"), size, True)
        elif size < 1024**2:
            size = locale.format_string(_("%.1f kB"), size/1024., True)
        elif size < 1024**3:
            size = locale.format_string(_("%.1f MB"), size/(1024.**2), True)
        else:
            size = locale.format_string(_("%.1f GB"), size/(1024.**3), True)
        cell.set_property("text", size)

    # Render a download speed in a CellRenderer
    def _render_speed(self, col, cell, model, iter, data=None):
        with gtk.gdk.lock:
            speed = model.get_value(iter, 4)
        if speed <= 0.:
            speed = ""
        elif speed < 1024.:
            speed = locale.format_string(_("%d B/s"), int(speed), True)
        elif speed < 1024.**2:
            speed = locale.format_string(_("%.1f kB/s"), speed/1024., True)
        else:
            speed = locale.format_string(_("%.1f MB/s"), speed/(1024.**2), True)
        with gtk.gdk.lock:
            cell.set_property("text", speed)

    # Render the progress of a download in a CellRenderer
    def _render_progress(self, col, cell, model, iter, data=None):
        with gtk.gdk.lock:
            total, downloaded = model.get(iter, 2, 3)
            cell.set_property("value", 100.*downloaded/total)

    # Render the ETA of a download in a CellRenderer
    def _render_eta(self, col, cell, model, iter, data=None):
        with gtk.gdk.lock:
            total_size, size, speed = model.get(iter, 2, 3, 4)
        eta = []
        if speed > .001:
            eta_s = int((total_size - size) / speed)
            eta_m, s = divmod(eta_s, 60)
            eta_h, m = divmod(eta_m, 60)
            eta_d, h = divmod(eta_h, 24)
            y, d = divmod(eta_d, 365)
            if y > 0:
                eta.append(locale.format_string(_("%d y"), y))
            if d > 0:
                eta.append(locale.format_string(_("%d d"), d))
            if h > 0:
                eta.append(locale.format_string(_("%d h"), h))
            if m > 0:
                eta.append(locale.format_string(_("%d m"), m))
            if s > 0 or len(eta) == 0:
                eta.append(locale.format_string(_("%d s"), s))
        eta = " ".join(eta)
        with gtk.gdk.lock:
            cell.set_property("text", eta)

    # Refresh the TreeView using the Put.io API
    def refresh(self, data=None):
        t = threading.Thread(target=self._get_folder, args=(0, None, ""))
        self.tree.clear()
        t.start()

    # Fetch data from a Put.io folder and add it in the TreeStore
    def _get_folder(self, root, parent, path):
        items = self.api.get_items(parent_id=root, limit=0)
        dirs = []
        for it in items:
            pb = self._get_icon(TYPE_TO_ICON[it.type])                
            it_path = os.path.join(path, it.name)
            tree_iter = self.tree.append(parent,
                                         (it.name, int(it.size), pb, int(it.id),
                                          it.download_url, it_path))
            if it.is_dir:
                dirs.append((it.id, tree_iter, it_path))
        
        for (it_id, tree_iter, it_path) in dirs:
            self._get_folder(it_id, tree_iter, it_path)

    # Get an icon from the default theme, using a cache if possible
    def _get_icon(self, name):
        # Try from cache
        if name in self.icons:
            return self.icons[name]

        # Not in cache --> try to get it from Gtk and cache it
        with gtk.gdk.lock:
            pb = self.theme.load_icon(name, 16, 0)
        self.icons[name] = pb
        return pb

    # Download selected items
    def download(self, data=None):
        sel = self.tvf.get_selection()
        model, rows = sel.get_selected_rows()
        if len(rows) == 0:
            return
        
        for row in rows:
            tree_iter = model.get_iter(row)
            size, url, path = model.get(tree_iter, 1, 4, 5)
            if len(url) > 0:
                with gtk.gdk.lock:
                    self.list.append((path, url, size, 0, 0.))
        self.dl_event.set()

    # Remove selected items
    def remove(self, data=None):
        sel = self.tvf.get_selection()
        model, rows = sel.get_selected_rows()
        if len(rows) == 0:
            return
        
        names = []
        ids = []
        for row in rows:
            tree_iter = model.get_iter(row)
            name, id_ = model.get(tree_iter, 0, 3)
            names.append(name)
            ids.append(id_)

        txt = _("The following items will be removed:\n%s\nAre you sure you want to remove them?")
        files = ""
        for name in names:
            files += "- %s\n" % name
        txt = txt % files

        dlg = gtk.MessageDialog(self.win, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                                gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, txt)
        dlg.set_title(_("Really remove?"))
        resp = dlg.run()

        if resp == gtk.RESPONSE_YES:
            for id_ in ids:
                item = self.api.get_items(id=id_)[0]
                item.delete_item()
            self.refresh()
        dlg.destroy()

    # Quit the app
    def destroy(self, widget, data=None):
        self.dl_quit = True
        self.dl_event.set()
        gtk.main_quit()

    # Download manager thread
    def _download_thread(self):
        # Loop forever
        while True:
            if self.dl_quit:
                return
            
            # Try to fetch an item that has not been downloaded yet from the ListStore
            with gtk.gdk.lock:
                tree_iter = self.list.get_iter_first()
                while tree_iter is not None and self.list.get_value(tree_iter, 3) != 0:
                    tree_iter = self.list.iter_next(tree_iter)

            # If nothing is available, wait until something happens and try again
            if tree_iter is None:
                self.dl_event.wait()
                self.dl_event.clear()
                continue

            # If we have something, grab more informations
            with gtk.gdk.lock:
                name, url, total_size = self.list.get(tree_iter, 0, 1, 2)

            # Construct an absolute path
            name = os.path.join(os.path.expanduser("~"), "Downloads", name)
            try:
                os.makedirs(os.path.dirname(name))
            except OSError:
                pass
            
            # Already downloaded?
            done = False
            if os.path.isfile(name) and os.path.getsize(name) == total_size:
                with gtk.gdk.lock:
                    self.list.set_value(tree_iter, 3, total_size)
                done = True
            
            # Not downloaded yet: do it
            while not done:
                size = 0
                if os.path.isfile(name):
                    size = os.path.getsize(name)
                fp = open(name, "ab")
                
                curl = pycurl.Curl()
                curl.setopt(pycurl.URL, url)
                curl.setopt(pycurl.WRITEDATA, fp)
                #curl.setopt(pycurl.VERBOSE, 1)
                curl.setopt(pycurl.NOSIGNAL, 1)
                curl.setopt(pycurl.USERPWD, "%s:%s" % (self.username, self.password))
                curl.setopt(pycurl.FOLLOWLOCATION, 1)
                curl.setopt(pycurl.MAXREDIRS, 10)
                curl.setopt(pycurl.UNRESTRICTED_AUTH, 1)
                if size > 0:
                    curl.setopt(pycurl.RESUME_FROM, size+1)

                # Progress callback
                def __progress(dl_t, dl_d, up_t, up_d):
                    # Use function attribute as a static variable. Store the
                    # last values of timestamp + downloaded size, and use that
                    # to compute the current download speed
                    speed = 0.
                    cur = (time.time(), dl_d)
                    if len(__progress.tot) == 0:
                        __progress.tot.append(cur)
                    else:
                        # Check if the previous one is older than a second
                        last = __progress.tot[-1]
                        if cur[0] - last[0] >= 1.:
                            # Yes: update the variable
                            __progress.tot.append(cur)
                            __progress.tot = __progress.tot[-5:]
                            first = __progress.tot[0]
                            speed = (cur[1] - first[1]) / (cur[0] - first[0])
                    # Update the counters
                    with gtk.gdk.lock:
                        self.list.set_value(tree_iter, 3, dl_d)
                        if speed > 0.:
                            self.list.set_value(tree_iter, 4, speed)
                __progress.tot = []
                curl.setopt(pycurl.NOPROGRESS, 0)
                curl.setopt(pycurl.PROGRESSFUNCTION, __progress)

                # Now do the download
                try:
                    curl.perform()
                except:
                    traceback.print_exc(file=sys.stderr)
                    sys.stderr.flush()
                curl.close()
                fp.close()

                # Check if everything went fine
                size = os.path.getsize(name)
                with gtk.gdk.lock:
                    self.list.set(tree_iter, 3, size, 4, 0.)
                if size == total_size:
                    done = True
                else:
                    print "Something went wrong, trying again in a few seconds"
                    time.sleep(5)

            # Download over: schedule its removal
            with gtk.gdk.lock:
                glib.timeout_add(15000, self._download_remove, tree_iter)

    # Remove a finished download from the ListStore
    def _download_remove(self, tree_iter):
        with gtk.gdk.lock:
            self.list.remove(tree_iter)


if __name__ == "__main__":
    # i18n
    gettext.install("gputio")
    
    # Read config file
    config = ConfigParser.SafeConfigParser()
    config.read(("config",))
    username = config.get("account", "username")
    password = config.get("account", "password")
    apikey = config.get("api", "key")
    apisecret = config.get("api", "secret")

    gobject.threads_init()
    gputio = GPutIO(username, password, apikey, apisecret)
    gtk.main()
